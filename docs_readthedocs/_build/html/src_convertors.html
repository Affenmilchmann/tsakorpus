
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Source convertors &#8212; tsakorpus 2.0 documentation</title>
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Conversion-time morphological analysis" href="parsed_wordlist_format.html" />
    <link rel="prev" title="Forks" href="forks.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="source-convertors">
<h1>Source convertors<a class="headerlink" href="#source-convertors" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Before indexing, your corpus data has to be transformed into <span class="xref std std-doc">Tsakorpus JSON</span> format. Tsakorpus includes customizable source conversion scripts for a number of source file formats. However, if your format is not supported or you do not get the result you expected, you will have to write a convertor yourself.</p>
<p>All files related to the convertors are located in <code class="docutils literal notranslate"><span class="pre">/src_convertors</span></code>.</p>
<p>This is how it works:</p>
<ol class="arabic simple">
<li><p>You put your sorce files into the appropriate folder.</p></li>
<li><p>You edit configuration files.</p></li>
<li><p>You pick one of the Python scripts in <code class="docutils literal notranslate"><span class="pre">/src_convertors</span></code>, based on your data format, and run it.</p></li>
<li><p>You get the JSON files. If your corpus has media files, you also get cut and compressed media files.</p></li>
</ol>
</div>
<div class="section" id="paths">
<h2>Paths<a class="headerlink" href="#paths" title="Permalink to this headline">¶</a></h2>
<p>If you want to convert your corpus with one of the source convertors, you have to put your files into right folders. Start by creating an empty <code class="docutils literal notranslate"><span class="pre">/src_convertors/corpus</span></code> directory if it is not already there. After that, there are two possibilities:</p>
<div class="section" id="option-1-default-single-corpus">
<h3>Option 1 (default): single corpus<a class="headerlink" href="#option-1-default-single-corpus" title="Permalink to this headline">¶</a></h3>
<p>In this scenario, you are going to work with a single corpus in this Tsakorpus instance. In this case, all files pertaining to your corpus could be put directly to <code class="docutils literal notranslate"><span class="pre">/src_convertors/corpus</span></code>. All configuration files then will be located in <code class="docutils literal notranslate"><span class="pre">/src_convertors/corpus/conf_conversion</span></code>. If you have a <code class="docutils literal notranslate"><span class="pre">/src_convertors/conf_conversion</span></code> folder, you may delete it, or make sure that <code class="docutils literal notranslate"><span class="pre">corpus_name</span></code> in <code class="docutils literal notranslate"><span class="pre">/src_convertors/conf_conversion/conversion_settings.json</span></code> is empty.</p>
</div>
<div class="section" id="option-2-multiple-corpora-in-one-tsakorpus-instance">
<h3>Option 2: multiple corpora in one Tsakorpus instance<a class="headerlink" href="#option-2-multiple-corpora-in-one-tsakorpus-instance" title="Permalink to this headline">¶</a></h3>
<p>(This option is mostly useful for development purposes, so probably you do not need it.)</p>
<p>In this case, each corpus will occupy a separate folder in <code class="docutils literal notranslate"><span class="pre">/src_convertors/corpus</span></code>. For each corpus, you have to create a directory called <code class="docutils literal notranslate"><span class="pre">/src_convertors/corpus/%corpus_name%</span></code>. Two sets of configuration files are used, one located in <code class="docutils literal notranslate"><span class="pre">/src_convertors/conf_conversion</span></code> (global) and the other, in <code class="docutils literal notranslate"><span class="pre">/src_convertors/corpus/%corpus_name%/conf_conversion</span></code> (local). Whenever the two configuration files have the same keys, the one located inside the corpus directory overrides the global one. The main purpose of the <code class="docutils literal notranslate"><span class="pre">/src_convertors/conf_conversion/conversion_settings.json</span></code> file (the one higher up in the tree) is to tell the converter where to look for the source files, which is why the parameters <code class="docutils literal notranslate"><span class="pre">corpus_dir</span></code> (which equals <code class="docutils literal notranslate"><span class="pre">corpus</span></code> by default) and <code class="docutils literal notranslate"><span class="pre">corpus_name</span></code> (set it to your current <code class="docutils literal notranslate"><span class="pre">%corpus_name%</span></code>) have to be specified there. All the rest can be put to the lower configuration file. In what follows, replace <code class="docutils literal notranslate"><span class="pre">src_convertors/corpus/%corpus_name%</span></code> with <code class="docutils literal notranslate"><span class="pre">src_convertors/corpus/%corpus_name%</span></code>.</p>
</div>
</div>
<div class="section" id="source-files">
<h2>Source files<a class="headerlink" href="#source-files" title="Permalink to this headline">¶</a></h2>
<p>All source files have to have the same format and extension. If you want to include different types of files in the corpus, you have to create a separate corpus folder for each type, see Option 2 above.</p>
<p>The source files should be placed in <code class="docutils literal notranslate"><span class="pre">/src_convertors/corpus/%ext%</span></code>, where <code class="docutils literal notranslate"><span class="pre">%ext%</span></code> is their extension. If the extension is <code class="docutils literal notranslate"><span class="pre">json</span></code>, you have to name this directory <code class="docutils literal notranslate"><span class="pre">json_input</span></code> to avoid name collision with the target directory. This directory can have any number of subdirectories of arbitrary depth. After the files have been converted, the resulting JSON files will be located in <code class="docutils literal notranslate"><span class="pre">/src_convertors/corpus/json</span></code>. If you run CG3 disambiguation after that, the disambiguated JSON files will be located in <code class="docutils literal notranslate"><span class="pre">src_convertors/corpus/json_disamb</span></code>. If you have a media-aligned corpus, the source media files have to be located next to the corresponding ELAN/EXMARaLDA/TEI files (and referenced there). The resulting media files (compressed and split into pieces) will appear in <code class="docutils literal notranslate"><span class="pre">/src_convertors/corpus/media</span></code>.</p>
</div>
<div class="section" id="configuration-files">
<h2>Configuration files<a class="headerlink" href="#configuration-files" title="Permalink to this headline">¶</a></h2>
<p>The obligatory configuration files are <code class="docutils literal notranslate"><span class="pre">conversion_settings.json</span></code> and <code class="docutils literal notranslate"><span class="pre">categories.json</span></code>. The latter describes which tags correspond to which grammatical categories and has the same format as <code class="docutils literal notranslate"><span class="pre">categories.json</span></code> in the main configuration directory (see <span class="xref std std-doc">categories</span>). <code class="docutils literal notranslate"><span class="pre">conversion_settings.json</span></code> contains a number of key-value pairs that describe the contents of the corpus and tell the convertors how to deal with it. Here is a common list of parameters; see also format-specific parameters in the description of individual convertors.</p>
<div class="section" id="general-parameters">
<h3>General parameters<a class="headerlink" href="#general-parameters" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">corpus_name</span></code> (string) – the name of the corpus. During source conversion, this parameter is only used to determine the path to the corpus files. If it does not exist or equals an empty string, it is assumed that you have only one corpus, which is located in <code class="docutils literal notranslate"><span class="pre">src_convertors/corpus</span></code>. If you have multiple corpora (<em>Option 2</em> above), then this field should be present in the global configuration file (<code class="docutils literal notranslate"><span class="pre">src_convertors/conf_conversion/conversion_settings.json</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">json_indent</span></code> (integer) – sets the number of whitespaces in one indent in the output JSON files. A value of <code class="docutils literal notranslate"><span class="pre">-1</span></code> means no indentation and no newlines. You only need indentation if you want to look at the output files in a text editor; otherwise, do not turn it on to save disk space.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gzip</span></code> (Boolean) – whether the resulting JSON file should be gzipped (which will take slightly more time, but much less disk space).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">languages</span></code> (list of strings) – names of the languages in your corpus. The order is important, since integer IDs are used instead of language names in the JSON files. Index in this list is used as an ID for each language. The actual language names are used in some other parameters in <code class="docutils literal notranslate"><span class="pre">conversion_settings.json</span></code>.</p></li>
</ul>
</div>
<div class="section" id="metadata">
<h3>Metadata<a class="headerlink" href="#metadata" title="Permalink to this headline">¶</a></h3>
<p>In most cases, it is expected that metadata for your texts (such as title, author or genre) are stored in a single file in <code class="docutils literal notranslate"><span class="pre">src_convertors/corpus</span></code>.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">meta_filename</span></code> (string) – the name of the metadata file. CSV and <a class="reference external" href="https://exmaralda.org/en/corpus-manager-en/">Coma</a> formats are recognized. In the case of CSV, the file should have tab-delimited format where each line represents one source file, the first column contains the name of the file and other columns contain all the metadata, one column per metadata field. In the case of a Coma file, see also <code class="docutils literal notranslate"><span class="pre">coma_meta_conversion</span></code> parameter below.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">meta_fields</span></code> (list of strings) – list of metadata field names. The values for the listed fields should appear in the metadata file in the same order: value for the first field in the first column, and so on. The name of the first metadata field should be <code class="docutils literal notranslate"><span class="pre">filename</span></code>. In the metadata file, it corresponds to the first column that contains the name of the file being described by that line.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">meta_files_ext</span></code> (Boolean) – whether the filenames in the metadata file have extensions.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">meta_files_dir</span></code> (Boolean) – whether the filenames in the metadata file have full paths rooted by <code class="docutils literal notranslate"><span class="pre">/src_convertors/corpus/%ext%</span></code>. If it is set to <code class="docutils literal notranslate"><span class="pre">false</span></code>, it is assumed that the names of the source files are unique regardless of where they exist within the subtree.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">meta_files_case_sensitive</span></code> (Boolean) – whether the filenames in the metadata file should be treated as case sensitive.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nometa_skip</span></code> (Boolean, optional) – whether the files not referenced in the metadata should be skipped. Defaults to <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">exclude_by_meta</span></code> (list of dictionaries, optional) – list of dictionaries, each of which contains a rule that determines which input documents should be skipped based on their metadata values. A document is skipped if it conforms to at least one rule. A document conforms to the rule if its metadata contains all the key-value pairs present in the rule, while possibly containing other keys. Defaults to empty list.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">coma_meta_conversion</span></code> (dictionary, optional) – determines which communication-level description fields from a Coma metadata file have to be used and what metadata fields they map to. Only usable with the Coma metadata files.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">speaker_meta_filename</span></code> (string, optional) – the name of the JSON file with metadata for individual speakers (for the ELAN convertor). The file should contain a dictionary where the keys are the codes of the speakers and the values are dictionaries with their metadata (fields and plain string/integer values). Here is an example of how such a file could look like:</p></li>
</ul>
<div class="highlight-xml notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span></pre></div></td><td class="code"><div class="highlight"><pre><span></span>{
  &quot;AB&quot;: {
    &quot;gender&quot;: &quot;F&quot;,
    &quot;origin&quot;: &quot;Moscow&quot;
  },
  &quot;PR&quot;: {
    &quot;gender&quot;: &quot;M&quot;,
    &quot;origin&quot;: &quot;New York&quot;
  }
}
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="tokenization-sentence-segmentation-and-cleaning">
<h3>Tokenization, sentence segmentation and cleaning<a class="headerlink" href="#tokenization-sentence-segmentation-and-cleaning" title="Permalink to this headline">¶</a></h3>
<p>These parameters are taken into account in scenarios where Tsakorpus performs tokenization and/or sentence splitting itself (which is not always the case).</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sent_end_punc</span></code> (string) – regexp used to decide if current token ends the sentence. It could equal something like <code class="docutils literal notranslate"><span class="pre">(?:[.!?;;]+(?:[)\\]}&gt;/»]|$)|\\\\n)</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sent_start</span></code> (string) – regexp used to decide if current token can start the sentence. It could equal something like <code class="docutils literal notranslate"><span class="pre">^[A-Z]</span></code>. If <code class="docutils literal notranslate"><span class="pre">sent_end_punc</span></code> matches a token, but <code class="docutils literal notranslate"><span class="pre">sent_start</span></code> does not match the next token, no sentence break is inserted.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">abbreviations</span></code> (list of strings) – list of tokens that should be considered abbreviations, so that a fullstop following them does not count as a sentence breaker.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">newline_ends_sent</span></code> (Boolean) – whether a newline character should break the sentence no matter what. This is relevant e.g. for article or chapter headers, which usually do not end with any punctuation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">transparent_punctuation</span></code> (string, optional) – regexp that determines which punctuation should be considered “transparent”, i.e. should not be counted when calculating distances between words for a multiword query. This parameter influences the assignment of <code class="docutils literal notranslate"><span class="pre">sentence_index</span></code> values, which are added to words and punctuation marks at conversion time and then used in multiword queries at search time. Defaults to <code class="docutils literal notranslate"><span class="pre">^</span> <span class="pre">*$</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">non_word_internal_punct</span></code> (list of strings, optional) – list of non-letter characters that should never be treated as word-internal during tokenization (if built-in tokenization is used). Defaults to the newline character; whitespace is always included. For example, a tokenizer with default options will consider words like <em>bla-bla-bla</em> to constitute single tokens, but if you add hyphen to this list, <em>bla-bla-bla</em> will be split into three tokens.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">special_tokens</span></code> (dictionary, optional) – determines which tokens have to be treated in a special way when performing automatic tokenization. Each key is a regex, and the corresponding value is a dictionary that should be inserted in the JSON files as an object representing that token. E.g. <code class="docutils literal notranslate"><span class="pre">&quot;&lt;(REPOST|USER|LINK)&gt;&quot;:</span> <span class="pre">{&quot;wtype&quot;:</span> <span class="pre">&quot;punct&quot;}</span></code> would lead to tokens <code class="docutils literal notranslate"><span class="pre">&lt;REPOST&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;USER&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;LINK&gt;</span></code> being tokenized as such (i.e. the angle brackets will not become separate tokens) and being treated as punctuation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">capitalize_sentences</span></code> (Boolean, optional) – whether the first letter of the first word in each sentence should be automatically capitalized. Defaults to <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">convert_quotes</span></code> (Boolean) – whether simple quotation marks should be converted to something typographically better-looking. This makes sense for some European languages, e.g. German, French or Russian.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">left_quot_mark</span></code> (string) – a replacement for a left-side double quotation mark (such as <code class="docutils literal notranslate"><span class="pre">«</span></code> or <code class="docutils literal notranslate"><span class="pre">»</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">right_quot_mark</span></code> (string) – a replacement for a right-side double quotation mark (such as <code class="docutils literal notranslate"><span class="pre">«</span></code> or <code class="docutils literal notranslate"><span class="pre">»</span></code>).</p></li>
</ul>
</div>
<div class="section" id="morphological-analysis">
<h3>Morphological analysis<a class="headerlink" href="#morphological-analysis" title="Permalink to this headline">¶</a></h3>
<p>These parameters are relevant in the scenarios where you have no POS tagging / morphological annotation in the texts yet, but would like to add some at the conversion stage. The only way of doing so right now is providing Tskorpus convertors with a pre-analyzed word list (or several lists, if you have multiple languages). Analyses from that list will be inserted into the JSON files. You have to put analyzed word list(s) to <code class="docutils literal notranslate"><span class="pre">src_convertors/copus</span></code>. If some of the words have multiple ambiguous analyses and you would like to disambiguate them using <a class="reference external" href="https://visl.sdu.dk/cg3/single/">CG3</a>, you can also put a CG3 rule list to the same folder. Note that you have to install CG3 to use it (<code class="docutils literal notranslate"><span class="pre">apt-get</span> <span class="pre">install</span> <span class="pre">cg3</span></code> on Linux; download it and put the path to the binary to the <code class="docutils literal notranslate"><span class="pre">PATH</span></code> variable on Windows).</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">parsed_wordlist_filename</span></code> (string, optional) – the name of the file with the morphologically annotated word list. If you have several lists for different languages, the value should be a dictionary where keys are the names of the languages and values are the names of the files.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">parsed_wordlist_format</span></code> (string, optional) – the format of the annotated word list. Currently, only the <code class="docutils literal notranslate"><span class="pre">xml_rnc</span></code> option is available, which means a list of XML-represented words in the format used in Russian National Corpus. See the description of this format <a class="reference internal" href="parsed_wordlist_format.html"><span class="doc">here</span></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gramtags_exclude</span></code> (list of strings, optional) –  grammatical tags that should be excluded from the analyses. Defaults to empty list.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cg_disambiguate</span></code> (Boolean, optional) – whether your corpus has to be disambiguated with the Constraint Grammar rules after the annotation. Defaults to <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cg_filename</span></code> (dictionary, optional) – names of the CG3 rule files (if you want to disambiguate your corpus). The files should be located in <code class="docutils literal notranslate"><span class="pre">src_convertors/corpus/</span></code>. The value of this field is a dictionary where the keys are the names of the languages and the values are the names of the corresponding files. You are not required to list all the languages you have.</p></li>
</ul>
</div>
</div>
<div class="section" id="the-convertors">
<h2>The convertors<a class="headerlink" href="#the-convertors" title="Permalink to this headline">¶</a></h2>
<p>There are several source convertors for different input formats. Each of them is implemented as a class and is located in one Python file:</p>
<div class="section" id="commonly-used-convertors">
<h3>Commonly used convertors<a class="headerlink" href="#commonly-used-convertors" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p><span class="xref std std-doc">Plain text convertor</span>: <code class="docutils literal notranslate"><span class="pre">txt2json.py</span></code>.</p></li>
<li><p><a class="reference internal" href="eaf2json.html"><span class="doc">ELAN media-aligned files convertor</span></a>: <code class="docutils literal notranslate"><span class="pre">eaf2json.py</span></code>.</p></li>
<li><p><span class="xref std std-doc">Fieldworks FLEX glossed texts convertor</span>: <code class="docutils literal notranslate"><span class="pre">xml_flex2json.py</span></code>.</p></li>
<li><p><a class="reference internal" href="xml_rnc2json.html"><span class="doc">Convertor of morphologically annotated XML (possibly parallel)</span></a> in one of the formats used by Russian National Corpus: <code class="docutils literal notranslate"><span class="pre">xml_rnc2json.py</span></code>.</p></li>
</ul>
</div>
<div class="section" id="project-specific-and-ad-hoc-convertors">
<h3>Project-specific and ad-hoc convertors<a class="headerlink" href="#project-specific-and-ad-hoc-convertors" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>HZSK ISO/TEI media-aligned files convertor: <code class="docutils literal notranslate"><span class="pre">iso_tei_hamburg2json.py</span></code>.</p></li>
<li><p>EXMARaLDA media-aligned files convertor (works only for non-segmented EXB files where events coincide with segments): <code class="docutils literal notranslate"><span class="pre">exmaralda_hamburg2json.py</span></code>.</p></li>
<li><p>Convertor for JSON files obtained by harvesting social media with a <a class="reference external" href="https://github.com/timarkh/vk-texts-harvester">VK text harvester</a>: <code class="docutils literal notranslate"><span class="pre">social_networks2json.py</span></code>.</p></li>
<li><p>Plain-text questionnaire convertor: <code class="docutils literal notranslate"><span class="pre">txt_questionnaires2json.py</span></code>.</p></li>
<li><p>Convertor for a YAML-like format used by the Morphy annotator: <code class="docutils literal notranslate"><span class="pre">morphy_yaml2json.py</span></code>.</p></li>
</ul>
<p>Please see the documentation pages for individual convertors to find out how they can be used.</p>
</div>
</div>
<div class="section" id="running-a-convertor">
<h2>Running a convertor<a class="headerlink" href="#running-a-convertor" title="Permalink to this headline">¶</a></h2>
<p>When you are ready with the configuration and the source files are stored in the relevant folder, all you have to do is to run the corresponding Python file and wait until it terminates. If your corpus consists of several parts stored in different formats, you may process them one by one with different source convertors and put the resulting JSONs in one place. The resulting files will be stored in <code class="docutils literal notranslate"><span class="pre">/src_convertors/corpus/json</span></code> or, if you used CG3 disambiguation, in <code class="docutils literal notranslate"><span class="pre">/src_convertors/corpus/json_disamb</span></code>.</p>
<p>### Processing glossed text (xml_flex2json, iso_tei_hamburg2json, exmaralda_hamburg2json, eaf2json)
The default way of representing word-level morphological information in corpus linguistics is to assign each word a grammatical tag or a set of tags. Each tag represents one value of one particular morphosyntactic category. Part-of-speech (POS) tags are the most common example, but corpora of morphologically rich languages often have tags for other categories, such as tense, number or case. Information about lexical classes, such as animate nouns or motion verbs, can also be encoded in such a way. In tsakorpus, each tag is a string, and all tags are split into classes (e.g. “case tags”) in <code class="docutils literal notranslate"><span class="pre">categories.json</span></code> (see <code class="docutils literal notranslate"><span class="pre">configuration.md</span></code>).</p>
<p>In typology and language documentation, however, another approach is often used, which is called glossing. Glossing means that each word is split into morphemes, and each morpheme gets a label, called gloss, that summarizes the morphosyntactic values expressed in it. Stems/roots are usually glossed with their English translation, although translations in other major metalanguages are also common. The most widely adopted glossing styleguide is the [Leipzig glossing rules](<a class="reference external" href="https://www.eva.mpg.de/lingua/resources/glossing-rules.php">https://www.eva.mpg.de/lingua/resources/glossing-rules.php</a>).</p>
<p>However, if only glosses are present in the annotation, it may affect the search functionality of the corpus in a negative way. To address this problem, tsakorpus source convertors offer a possibility of converting one’s glosses into grammatical tags. Please refer to <span class="xref std std-doc">tags_vs_glosses</span> for more detailed explanations and the format of the conversion rules.</p>
<p>### Fieldworks FLEX files conversion (flex2json)
To convert your FLEX database, you first have to export it using the “Verifiable generic XML” option. When exporting, the “Interlinear texts” section should be active, the “Analyze” tab should be open, and all relevant annotation tiers should be switched on and visible.</p>
<p>There are several problems with Fieldworks files. First, XMLs coming from different versions of Fieldworks look differently. Second, the exported XML does not have any connection to the dictionary (there should be one, but it does not work as of now), so any dictionary information not present in the interlinear will be lost. Third, Fieldworks does not have the lemma concept, so either you will have stems instead of lemmata, or you will have to somehow reconstruct lemmata from stems and grammatical information yourself. Fourth, all inflectional morphological information is stored in the glosses, so if some category is not overtly marked (which is common for e.g. singular, nominative/absolutive or imperative) and you do not have null morphemes, you will not be able to search for it unless you reconstruct it.</p>
<p>Tsakorpus FLEX convertor addresses the first problem by using flexible data extraction that was tested on different kinds of XML. Nevertheless, I cannot guarantee that it will work with any FLEX XML. I do not have any solution for second and third problems. The fourth problem can be solved by writing a set of rules which will allow the convertor to reconstruct hidden categories (see <span class="xref std std-doc">tags_vs_glosses</span>).</p>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">tsakorpus</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="faq.html">Short FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="forks.html">Forks</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Source convertors</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#paths">Paths</a></li>
<li class="toctree-l2"><a class="reference internal" href="#source-files">Source files</a></li>
<li class="toctree-l2"><a class="reference internal" href="#configuration-files">Configuration files</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-convertors">The convertors</a></li>
<li class="toctree-l2"><a class="reference internal" href="#running-a-convertor">Running a convertor</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="parsed_wordlist_format.html">Conversion-time morphological analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="eaf2json.html">ELAN convertor</a></li>
<li class="toctree-l1"><a class="reference internal" href="xml_rnc2json.html">RNC XML convertor</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="forks.html" title="previous chapter">Forks</a></li>
      <li>Next: <a href="parsed_wordlist_format.html" title="next chapter">Conversion-time morphological analysis</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, Timofey Arkhangelskiy.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.5.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/src_convertors.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>